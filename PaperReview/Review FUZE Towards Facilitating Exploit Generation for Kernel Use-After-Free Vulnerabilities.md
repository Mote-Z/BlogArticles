Title = "Review ——FUZE: Towards Facilitating Exploit Generation for Kernel Use-After-Free Vulnerabilities "

description = "介绍了UAF漏洞利用辅助框架 FUZE"

tags = ["论文"] 

publishtime = 2020-05-29T13:12:54 
lastedittime = 2020-05-29T13:12:54
uuid = "34314bfa-a97f-4454-8bde-322f32081dcf"
-+_+-

> 在漏洞修补的过程中，甲方不可能对所有的漏洞进行修补，那样的代价太大，根据软件开发的理论，一个软件约到后面，修补所付出的代价越大，所以一般来说都是对漏洞的可利用性进行评估，将可利用性高、利用难度低的漏洞的置为高优先级。然而对漏洞可利用性的评估往往是困难而有复杂的一项工作，尤其是内核中的 UAF 漏洞，一般看是否有可验证的漏洞利用PoC，而一个降低评估难度和复杂度的框架就显得很有必要了。
## 一：主要内容

​	本文设计了一个UAF漏洞利用辅助框架 FUZE。FUZE 主要利用的是 kernel fuzzing （内核模糊测试） 以及 symbolic execution （符号执行）来识别内核 UAF 漏洞，通过分析并验证其系统调用的可利用性，利用 dynamic tracing （动态跟踪）和 constraint solver （约束求解器）来促进对内核 UAF 漏洞利用的开发。

### UAF 漏洞

Use After Free （UAF）漏洞是一种常见的内存损坏漏洞，它有可能对内存数据造成破坏，从而导致各种严重的后果（任意代码执行、权限提升、严重的数据泄露等等）

内核 UAF 利用的关键地方在于 
1. 确定内存对象的释放时机
2. 基于释放对象的大小和heap allocators（堆管理器）类型，选取合适的 syscall （系统调用）并构造适合的参数，利用堆喷射技术将攻击者可控的数据喷射到内核中，使其占据漏洞对象释放前所处的位置，使得之对释放对象重引用时出现错误，从而操作其内容



### 挑战

1. 由于符号执行技术面临的挑战（路径爆炸、环境建模和多线程模拟），因此这些程序分析技术只适用较为简单的程序，针对于复杂性和扩展性都比较高的内核 UAF 漏洞利用生成方面并不适用。
2. 目前的漏洞利用技术的研究主要针对栈溢出漏洞、格式化字符串漏洞和堆溢出漏洞等简单漏洞类型，可以简单的通过改变输入字符串从而改变漏洞触发的上下文，从而促进漏洞的利用，而 UAF 需要对目标程序空间和时间的精确控制，无法凭借简单的改变输入来触发漏洞。



### 堆喷射

一般而言，堆喷射的目的是利用可控数据占据已释放漏洞对象的位置，从而有机会将系统的控制流重定向到未授权的操作（权限提升或者严重的数据泄露）



### 根据已知 PoC开发 Exploit的过程

在尝试对内核 UAF 漏洞进行利用时，安全分析人员需要根据PoC来进行开发

![](https://blog-1301895608.cos.ap-guangzhou.myqcloud.com/img2/20200529094637.png)

1. 首先需要识别导致悬空指针的系统调用和解引该指针的系统调用
2. 分析该悬空指针指向的漏洞数据对象的大小和堆分配器的类型，选择合适的系统调用，能在悬空指针出现和解引的时间窗口内执行堆喷射
3. 根据已知PoC，仔细计算堆喷射的数据内容，然后调整堆喷射对应的系统调用的参数
4. 最后需要手动修正PoC来完成漏洞的利用

即使如此，编写UAF漏洞的利用仍然是具有挑战性的。

## 二：案例分析

下面是一个内核 UAF 漏洞（CVE-2017-15649）PoC的核心代码片段

```c
void *task1(void *unused) {
    ...
    int err = setsockopt(fd, 0x107, 18, ..., ...);
}

void *task2(void *unused) {
	int err = bind(fd, &addr, ...);
}

void loop_race() {
	...
    while(1) {
        fd = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
        ...
        // create two racing threads
        pthread_create (&thread1, NULL, task1, NULL);
        pthread_create (&thread2, NULL, task2, NULL);

        pthread_join(thread1, NULL);
        pthread_join(thread2, NULL);

        close(fd);
    }
}

int main() {
    ...
	loop_race();
    ...
}
```

**setsockopt**

`setsockopt`是Linux的一个系统调用。在通过某种类型的套接字调用（13行）时，会在Linux 内核中创建一个新对象，然后把它插入一个双向链表的头节点。

![setsockopt](https://blog-1301895608.cos.ap-guangzhou.myqcloud.com/img2/20200529101559.png)

**条件竞争**

在16行和17行，PoC创建了两个相互竞争的线程，无限循环重复调用 `setsockopt`与`bind`，这时候PoC会触发一个数据访问竞争，我们知道，对数据的访问竞争很有可能导致意外的情况，这里导致对`setsockopt`新添加的对象的标志位进行意外操作。

**导致悬空指针**

每次循环结束之前，PoC会调用`close（）`将`setsockopt`新添加的对象释放并从链表上脱链。由于条件竞争导致对其标志位的意外操作，系统并不能成功改写其头节点的 next 指针，所以留下一个指向被释放对象的悬空指针（dangling pointer）

![](https://blog-1301895608.cos.ap-guangzhou.myqcloud.com/img2/20200529102426.png)

**写入数据**

在悬空指针出现的下一次循环，PoC再次通过系统调用添加一个新的对象

![](https://blog-1301895608.cos.ap-guangzhou.myqcloud.com/img2/20200529102606.png)

在插入新节点的时候，引用了头节点的next悬空指针，将其对象的 prev 指针指向自身，从而导致非法写操作，并在后续执行中导致内核崩溃。

这个PoC只是提供了将新对象的地址写入悬空指针所指向对象的内核堆区域的能力，但是这个新对象地址以及写入的堆地址都是不可控的，这使得该PoC很难被利用，但是并不是没有可能。

**sendmsg**

`sendmsg()`可以解引用双向链表中新加入的对象指针并访问其数据，当悬空指针解引用之前，它以另一种方式解引用悬空指针。

如果在`close()`调用之后插入构造好的 `sendmsg()`系统调用，可以在悬空指针的产生和解引用操作的时间窗口内，将悬空指针指向已释放的内存，并读取其中数据作为函数指针进行间接调用，这就改变崩溃时的上下文，可以利用这个进行控制流劫持。

这种方式甚至可以绕过部分内核利用的缓解机制（例如 SMEP 和 SMAP）

![](https://blog-1301895608.cos.ap-guangzhou.myqcloud.com/img2/20200529103946.png)





## 三：FUZE设计与实现

### 需求设计

1. 需要追踪漏洞对象、悬空指针的出现和引用，便于分析者选择合适syscall和堆喷的时间窗口
2. 需要辅助合成新的 PoC ，导致不同的上下文
3. 需要自动选择有用的上下文
4. 需要自动计算堆喷射的数据

### 顶层设计

运行PoC，结合现有的内存检测工具KASAN和动态跟踪的方法，获取漏洞对象以及时间窗口，通过模糊测试在时间窗口内插入代码，自动定位可以改变原始PoC上下文的系统调用，根据利用方法总结可利用性状态机（环境建模），使用符号执行技术自动评估相关上下文的可利用性。

### 具体设计

1. 关键信息搜集：KASAN内存检测 + 动态追踪（ftrace），得到悬空指针如何被引用，以及追踪悬空指针属于哪个变量
2. 内核模糊测试
	- 初始化fuzzing上下文，准确定位悬空指针的时间窗口，消除PoC中悬空指针解引用的干扰，采用插桩，悬空指针产生以后就导向内核fuzzing（根据KASAN日志信息，寻找引用DP的代码语句，找到对应变量的内存地址，当出现该对象则重定向到内核fuzzing）
	- 基于上下文的内核 fuzzing，采用开源内核fuzzing框架 syzkaller 
3. 符号执行
	- 目的是为了确定哪种状态能使内核执行导向可利用的状态机，计算堆喷射数据
	- 符号执行的设置
	- 可利用状态机的识别

### 技术讨论

1. 内核部分符号执行的局限性
	- 不能用来分析对多内核线程切换对漏洞可利用性的影响
	- 不能建模中断处理对漏洞可利用性的影响
	- 内存符号化假设依赖找到适合的内核堆喷、占位对象
2. 堆溢出漏洞利用

## 四：实验评估

​	为了进行实验评估，详尽地搜索了过去 5 年中发现的 Linux 内核 UAF 漏洞，并排除了与特殊硬件设备相关的 UAF 漏洞以及未能发现与 CVE 相对应的 PoC 程序的漏洞。

​	最终获得了一个包含 15 个内核 UAF 漏洞及其 PoC 的数据集， 这些漏洞存在于各种版本的 Linux 内核中。

​	使用两种编译，一种开启KASAN与KOV，一种不开启；不考虑ASLR；

![FUZE的结果](https://blog-1301895608.cos.ap-guangzhou.myqcloud.com/img2/20200529121551.png)

![模糊测试与符号执行的性能](https://blog-1301895608.cos.ap-guangzhou.myqcloud.com/img2/20200529122205.png)

### 结果

1. 原本只有 5 个公开可用的漏洞可以绕过 SMEP ，而 FUZE 找到了 5 个额外的绕过SMEP的漏洞利用
2. 原本只有 2 个公开的能绕过 SMAP 的漏洞利用 ， 而 FUZE 找到了3 个
3. FUZE 可以通过自动发现更多漏洞触发上下文、自动在漏洞触发上下文中发现并评估利用原语，帮助安全分析人员生成可提权的 UAF 漏洞利用。





## 五：阅读总结

本文结合现有的内存检测工具KASAN和动态跟踪框架 ftrace，获取到UAF的漏洞对象以及时间窗口等相关信息，通过模糊测试框架syzkaller 进行fuzzing，在时间窗口内插入代码，自动定位可以改变原始PoC上下文的系统调用，生成可利用性状态机（环境建模），使用符号执行技术自动评估相关上下文的可利用性。

其中如何确定悬空指针的出现，KASAN+ftrace 获取相关信息，只要出现对应变量，就重定向到内核fuzzing，关于如何对内核进行fuzzing部分的思路也值得学习

相关exploit

https://github.com/ww9210/Linux_kernel_exploits

